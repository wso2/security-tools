/*
 * Zed Attack Proxy (ZAP) and its related class files.
 *
 * ZAP is an HTTP/HTTPS proxy for assessing web application security.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.zaproxy.zap.extension.pscanrulesAlpha;

import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Map;
import org.apache.log4j.Logger;
import org.apache.commons.collections.map.LRUMap;
import org.parosproxy.paros.Constant;

/**
 * A class to cache and return vulnerabilities on a per-product, product version basis 
 * @author 70pointer@gmail.com
 *
 */
public class VulnerabilityCache {

	private static VulnerabilityCache instance;
	@SuppressWarnings("unchecked")
	private Map <Product, LinkedList<CVE>> vulnerabilityMap = Collections.synchronizedMap (new LRUMap (50)); //max: 50 sets of vulnerabilities		
	private static Logger log = Logger.getLogger(VulnerabilityCache.class);

	/**
	 * a db connection that we will use to get vulnerability information for different software versions
	 */
	private static Connection vulnDbconnection = null;

	/**
	 * statically open up the SQLite database containing the vulnerability information 
	 */
	static {
		File vulnDbFile = new File(Constant.getZapHome() + File.separator + "vulnerabilities.db");
		if ( ! vulnDbFile.exists()) {
			log.error ("Could not find the vulnerability database file: "+ vulnDbFile.getAbsolutePath());
		} else 
		{
			if (log.isDebugEnabled()) log.debug ("The vulnerability database file exists: "+ vulnDbFile.getAbsolutePath());
			try {
				Class.forName("org.sqlite.JDBC");
				String sqliteConnectionUrl = "jdbc:sqlite:" + vulnDbFile.getAbsolutePath();
				vulnDbconnection = DriverManager.getConnection(sqliteConnectionUrl);
				if (vulnDbconnection == null) {				 
					log.error ("Could not open a JDBC connection to SQLite file "+ vulnDbFile.getAbsolutePath());
				} 
				if (log.isDebugEnabled()) log.debug ("Loaded the vulnerability database file: "+ vulnDbFile.getAbsolutePath());
			} catch (ClassNotFoundException e) {
				log.error ("Could not load SQLite JDBC driver while trying to open a connection to the vulnerability database", e);
			} 
			catch (SQLException e) {
				log.error ("A SQL exception occured while trying to open a connection to the vulnerability database", e);
			}
		}
	}

	private VulnerabilityCache () {
		if (log.isDebugEnabled()) log.debug("Initialising the Vulnerability Cache");			
	}

	public static synchronized VulnerabilityCache getSingleton () {
		if ( instance == null ) createSingleton();
		return instance;
	}

	private static synchronized void createSingleton() {
		if (instance == null) { 
			instance = new VulnerabilityCache();
		}
	}

	public LinkedList<CVE> getVulnerabilities (final Product p) throws Exception {

		if ( p == null ) return null;
		
		//if ( p.getProductType() != Product.ProductType.PRODUCTTYPE_WEBSERVER) {
		//	throw new Exception ("Product Type "+ p.getProductType() + " is not currently supported");
		//}
		
		if ( vulnerabilityMap.containsKey(p)) {
			if (log.isDebugEnabled()) log.debug("Cache HIT on product "+ p.getProductName() + ", "+p.getProductVersion());
			return vulnerabilityMap.get(p); 
		} else {
			if (log.isDebugEnabled()) log.debug("Cache MISS on product "+ p.getProductName() + ", "+p.getProductVersion());
			
			//find and cache the vulnerabilities for the product and version
			//we need to map the product information to a product id used in the database.  Luckily, there are only a few.			
			LinkedList <CVE> vulnlist = new LinkedList <CVE> ();
			PreparedStatement stmt = null;
			ResultSet rsVulns =null;

			//Use the "setString" method to protect against SQL injection on a malicious version string (which comes from some web server, after all)
			try {
				String sqlStatement = "select distinct v.cveid, v.cvss "
						+" from externalproducts ep "
						+" ,products p "
						+" ,versions ver " 
						+" ,versionstovulnerabilities vv " 
						+" ,vulnerabilities v "
						+" where ep.externalproductname = ? "  //1
						+" and ep.productid = p.productid "
						+" and p.productid = ver.productid "
						+" and case when ver.versionupdate != \"\" then ver.version || ep.productversiondelimiter || ver.versionupdate else ver.version end = ?"
						+" and ver.versionid = vv.versionid "
						+" and vv.cveid = v.cveid " 
						+" order by v.cvss desc, v.cveid asc "; 

				if (log.isDebugEnabled()) log.debug("Executing SQL for '"+ p.getProductName() + "', version '"+ p.getProductVersion() + "': "+ sqlStatement);

				stmt = vulnDbconnection.prepareStatement(sqlStatement);
				stmt.setString(1, p.getProductName());
				stmt.setString(2, p.getProductVersion());
				
				long tickTock1 = System.currentTimeMillis();
				rsVulns = stmt.executeQuery();				
				
				while (rsVulns.next()) {
					String cveid = rsVulns.getString(1);
					Double cvss = rsVulns.getDouble(2);	
					vulnlist.add(new CVE (cveid, cvss));
				}				
				long tickTock2 = System.currentTimeMillis();
				long elapsedMillis = tickTock2 -tickTock1; 				
				if (log.isDebugEnabled()) log.debug("SQL query took "+ elapsedMillis + " ms to execute and add as CVE objects");
			}
			catch (SQLException e) {
				//in this case, do not cache the results, since the SQL error might be transient.
				log.error("A SQL exception occurred while querying the vulnerabilities database for product '"+  p.getProductName() + "', version '"+ p.getProductVersion() + "'", e);
				vulnlist = null;
			} finally {
				//close statements, resultsets..
				if (rsVulns!=null) rsVulns.close();
				if (stmt!=null) stmt.close();			
			}
			if (vulnlist != null) {
				if (log.isDebugEnabled()) log.debug("Caching product "+ p.getProductName() + ", "+ p.getProductVersion());
				vulnerabilityMap.put(p, vulnlist);				
				return vulnlist;
			}
			else 
				return null;
		}	
	}
}
